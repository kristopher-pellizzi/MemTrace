#include <iostream>
#include <forward_list>
#include <fstream>
#include <cerrno>
#include <libgen.h>
#include <set>

#include "Wrapper.h"

#define ARGV_SIZE 128
#define REQUIRED_POSITIONAL_ARGUMENTS 2

using std::forward_list;
using std::set;

extern char** environ;

/*
    This small program has been thought as a wrapper to be launched by the fuzzer.
    The program expects only 2 additional command-line arguments:
        - The path to an input file
        - The path to the program to be analyzed

    The program, reads from the input file (generated by the fuzzer) and divides the content in 2 parts.
    
    1)  The last 128 B of the input file will be considered to be the command line arguments to be passed to the program
        in analysis. 
        Byte \x00 is considered a separator between arguments (it would be considered the terminator
        of the argument string by execve, anyway).
        The program will split the read byte sequence wherever a byte \x00 is found, creating an array of 
        TERMINATED argument strings.
        Then, spaces are removed from the beginning and end of the strings and empty strings 
        are filtered out of the array, keeping only those arguments with at least 1 byte (excluding \x00)

    2)  After having read the last 128 B of the input file, the file is truncated in order to cut those bytes
        and will be passed as an argument to the program to be analyzed (it is the real input file
        the program will read from)
*/

/*
    Functors
*/

class NotIsEmptyFunctor{
    public:
        bool operator()(unsigned char* s){
            return strlen((char*) s) != 0;
        }
};



/*
    ArgBytes class implementation
*/

ArgBytes::~ArgBytes(){
    // Every operation done on the argument array, simply change the pointers stored by the array
    // Nothing else is allocated, nor copied elsewhere. So, we must simply free the initial raw byte array
    // read by the input file.
    free(rawBytes);
}

unsigned char** ArgBytes::split(){
    // Split the bytes array at every byte '\x00', creating an array of strings out of it
    // of size listLen + 2, where listLen is the length of the list containing all the strings obtained
    // by splitting |rawBytes|. Also, set the last array element to be NULL.

    size_t listLen = 0;
    forward_list<unsigned char*> argList;
    char* startPtr = (char*) rawBytes;
    char* endPtr = startPtr + ARGV_SIZE - 1;
    char* currentPtr = startPtr;

    while(currentPtr <= endPtr){
        char* nullPtr = strchr(currentPtr, '\x00');
        if(nullPtr <= endPtr && currentPtr != nullPtr){
            argList.push_front((unsigned char*) currentPtr);
            ++listLen;
        }
        currentPtr = nullPtr + 1;
    }

    size = listLen;
    argArray = (unsigned char**) malloc(sizeof(char*) * (listLen + 2));
    size_t index = listLen + 1;
    argArray[index--] = NULL;
    for(auto iter = argList.begin(); iter != argList.end(); ++iter){
        argArray[index--] = *iter;
    }
    argArray[0] = NULL;
    
    return argArray;
}

unsigned char* ArgBytes::strip(unsigned char* s){
    // Remove any kind of space from the beginning and the end of string |s|.
    // Avoid string de-allocation, copy and allocation. Simply return first non-space
    // character pointer and write '\x00' into the first space character following the string
    // NOTE: spaces in-between the string are kept unchanged
    unsigned char* start = s;

    while(isspace(*start) && *start != '\x00'){
        ++start;
    }
    
    unsigned char* end = start;
    s = start;
    while(*s != '\x00'){
        if(!isspace(*s)){
            end = s;
        }
        ++s;
    }
    *(end + 1) = '\x00';
    return start;
}

unsigned char** ArgBytes::getArgs(){
    // Split @ "\x00"
    // Strip strings    
    // Filter empty strings
    // Create an array |args| out of the list (whose size is list_size + 2, to make space for executable path and last
    // NULL element)

    unsigned char** args = 
        filter(
            NotIsEmptyFunctor(), 
            map(
                strip, 
                split()
            )
        );

    return args;
}

size_t ArgBytes::getSize(){
    return size;
}



/*
    Program functions
*/

void path_error(char* path){
    std::cerr << path << " not found" << std::endl;
    exit(8);
}

void permission_error(char* path){
    std::cerr << "Requested permissions on " << path << " are not available" << std::endl;
    exit(9);
}

void checkPathExistence(char* path){
    if(access(path, F_OK)){
        path_error(path);
    };
}

void checkPermissions(char* path, int mode){
    if(access(path, mode)){
        permission_error(path);
    }
}

void positional_args_error(int parsed){
    std::cout << "Error: 2 positional arguments required, " << parsed << " given" << std::endl;
    exit(10);
}


int main(int argc, char* argv[]){
    
    if(argc < 2){
        positional_args_error(argc);
    }

    char* executablePath = argv[1];
    char* inputFilePath = argv[2];

    checkPathExistence(inputFilePath);
    checkPathExistence(executablePath);
    checkPermissions(inputFilePath, R_OK | W_OK);
    checkPermissions(executablePath, X_OK);

    std::ifstream inputFile(inputFilePath, std::ios::in | std::ios::binary);
    if(!inputFile){
        std::cerr << "Cannot open file " << inputFilePath << std::endl;
        exit(3);
    }

    inputFile.seekg(- ARGV_SIZE, std::ios_base::end);
    bool retried = false;
    while(inputFile.fail()){
        if(retried){
            std::cerr << "Error while seeking to position" << std::endl;
            exit(5);
        }
        std::cout << "Error trying to seek to the last 128 bytes of the file." << std::endl;
        std::cout << "Resetting to file beginning..." << std::endl;
        inputFile.clear();
        inputFile.seekg(0, std::ios_base::beg);
        retried = true;
    }

    unsigned long long off = inputFile.tellg();
    if(inputFile.fail()){
        std::cerr << "Something went wrong while retrieving file offset" << std::endl;
        exit(6);
    }

    unsigned char* rawBytes = (unsigned char*) malloc(sizeof(unsigned char) * ARGV_SIZE);
    inputFile.read((char*) rawBytes, ARGV_SIZE);
    if(inputFile.fail() && !inputFile.eof()){
        std::cerr << "Something went wrong while reading input file" << std::endl;
        exit(2);
    }

    inputFile.close();
    if(truncate(inputFilePath, off))
    {
        std::cerr << "File truncate failed" << std::endl;
        exit(7);
    }

    ArgBytes argBytes(rawBytes);
    char** args = (char**) argBytes.getArgs();

    args[0] = executablePath;

    for(int i = 3; i < argc; ++i){
        int index = atoi(argv[i]);
        if(index <= argBytes.getSize()){
            args[index] = inputFilePath;
        }
    }

    // Execute the program with arguments contained in |args|
    execve(executablePath, args, environ);
}