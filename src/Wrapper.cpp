#include <iostream>
#include <forward_list>
#include <fstream>
#include <cerrno>

#include "Wrapper.h"

#define ARGV_SIZE 128

using std::forward_list;

extern char** environ;

/*
    This small program has been thought as a wrapper to be launched by the fuzzer.
    The program expects only 2 additional command-line arguments:
        - The path to an input file
        - The path to the program to be analyzed

    The program, reads from the input file (generated by the fuzzer) and divides the content in 2 parts.
    
    1)  The last 128 B of the input file will be considered to be the command line arguments to be passed to the program
        in analysis. 
        Byte \x00 is considered a separator between arguments (it would be considered the terminator
        of the argument string by execve, anyway).
        The program will split the read byte sequence wherever a byte \x00 is found, creating an array of 
        TERMINATED argument strings.
        Then, spaces are removed from the beginning and end of the strings and empty strings 
        are filtered out of the array, keeping only those arguments with at least 1 byte (excluding \x00)

    2)  After having read the last 128 B of the input file, the file is truncated in order to cut those bytes
        and will be passed as an argument to the program to be analyzed (it is the real input file
        the program will read from)
*/

/*
    Functors
*/

class NotIsEmptyFunctor{
    public:
        bool operator()(unsigned char* s){
            return strlen((char*) s) != 0;
        }
};



/*
    ArgBytes class implementation
*/

ArgBytes::~ArgBytes(){
    // Every operation done on the argument array, simply change the pointers stored by the array
    // Nothing else is allocated, nor copied elsewhere. So, we must simply free the initial raw byte array
    // read by the input file.
    free(rawBytes);
}

unsigned char** ArgBytes::split(){
    // Set size to list length
    // During copy, also copy the \x00 byte, so that strings are always terminated
    // Append elements from last list element to the first
    // Append executable name

    // NOTE: not using strtok because the delimiter character may be '\x00'

    size_t listLen = 0;
    forward_list<unsigned char*> argList;
    char* startPtr = (char*) rawBytes;
    char* endPtr = startPtr + ARGV_SIZE - 1;
    char* currentPtr = startPtr;

    while(currentPtr <= endPtr){
        char* nullPtr = strchr(currentPtr, '\x00');
        if(nullPtr <= endPtr && currentPtr != nullPtr){
            argList.push_front((unsigned char*) currentPtr);
            ++listLen;
        }
        currentPtr = nullPtr + 1;
    }

    size = listLen;
    argArray = (unsigned char**) malloc(sizeof(char*) * (listLen + 2));
    size_t index = listLen + 1;
    argArray[index--] = NULL;
    for(auto iter = argList.begin(); iter != argList.end(); ++iter){
        argArray[index--] = *iter;
    }
    argArray[0] = NULL;
    
    return argArray;
}

unsigned char* ArgBytes::strip(unsigned char* s){
    // Avoid string de-allocation, copy and allocation. Simply return first non-space
    // character pointer and write '\x00' into the first space character following the string
    // NOTE: spaces in-between the string are kept unchanged
    unsigned char* start = s;

    while(isspace(*start) && *start != '\x00'){
        ++start;
    }
    
    unsigned char* end = start;
    s = start;
    while(*s != '\x00'){
        if(!isspace(*s)){
            end = s;
        }
        ++s;
    }
    *(end + 1) = '\x00';
    return start;
}

unsigned char** ArgBytes::getArgs(){
    // Split @ "\x00"
    // Strip strings    
    // Filter empty strings
    // Terminate each string
    // Append executable name at the beginning of the list
    // Create array out of the list
    // Return the array

    unsigned char** args = 
        filter(
            NotIsEmptyFunctor(), 
            map(
                strip, 
                split()
            )
        );

    return args;
}



/*
    Program functions
*/

void usage(){
    std::cout   << "wrapper <executable_path> <input_file_path>" << std::endl;
}

void path_error(char* path){
    std::cerr << path << " not found" << std::endl;
    exit(8);
}

void permission_error(char* path){
    std::cerr << "Requested permissions on " << path << " are not available" << std::endl;
    exit(9);
}

void checkPathExistence(char* path){
    if(access(path, F_OK)){
        path_error(path);
    };
}

void checkPermissions(char* path, int mode){
    if(access(path, mode)){
        permission_error(path);
    }
}

int main(int argc, char* argv[]){
    if(argc != 3){
        std::cerr << "Required parameter missing" << std::endl << std::endl;
        usage();
        exit(4);
    }

    char* inputFilePath = argv[2];
    char* executablePath = argv[1];

    checkPathExistence(inputFilePath);
    checkPathExistence(executablePath);
    checkPermissions(inputFilePath, R_OK | W_OK);
    checkPermissions(executablePath, X_OK);

    std::ifstream inputFile(inputFilePath, std::ios::in | std::ios::binary);
    if(!inputFile){
        std::cerr << "Cannot open file " << inputFilePath << std::endl;
        exit(3);
    }

    inputFile.seekg(-128, std::ios_base::end);
    bool retried = false;
    while(inputFile.fail()){
        if(retried){
            std::cerr << "Error while seeking to position" << std::endl;
            exit(5);
        }
        std::cout << "Error trying to seek to the last 128 bytes of the file." << std::endl;
        std::cout << "Resetting to file beginning..." << std::endl;
        inputFile.seekg(0, std::ios_base::beg);
        inputFile.clear();
        retried = true;
    }

    unsigned long long off = inputFile.tellg();
    if(inputFile.fail()){
        std::cerr << "Something went wrong while retrieving file offset" << std::endl;
        exit(6);
    }

    unsigned char* rawBytes = (unsigned char*) malloc(sizeof(unsigned char) * ARGV_SIZE);
    inputFile.read((char*) rawBytes, ARGV_SIZE);
    if(inputFile.fail() && !inputFile.eof()){
        std::cerr << "Something went wrong while reading input file" << std::endl;
        exit(2);
    }

    inputFile.close();
    if(truncate(inputFilePath, off))
    {
        std::cerr << "File truncate failed" << std::endl;
        exit(7);
    }

    ArgBytes argBytes(rawBytes);
    char** args = (char**) argBytes.getArgs();

    args[0] = executablePath;
    execve(executablePath, args, environ);
}