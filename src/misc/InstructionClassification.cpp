#include "InstructionClassification.h"

set<OPCODE> sseInstructions;

bool isSSEInstruction(INT32 extension){
    switch(extension){
        case XED_EXTENSION_SSE:
        case XED_EXTENSION_SSE2:
        case XED_EXTENSION_SSE3:
        case XED_EXTENSION_SSE4:
        case XED_EXTENSION_SSE4A:
            return true;
        
        default:
            return false;
    }
}

bool isSSEInstruction(OPCODE opcode){
    auto iter = sseInstructions.find(opcode);

    if(iter != sseInstructions.end())
        return true;
    
    return false;
}

/*
    We call an "auto mov" a mov instruction whose src and destination register is the same.
    This function is used to manage a very specific problem.
    Let's consider this example:
        1) Register rbx is loaded with uninitialized bytes
        2) There is (for some reason) a mov copying rbx into itself.
        3) Register rbx is used by some instruction
    
    Since mov instructions are not considered as register usages, the mov instruction at point 2) won't trigger the store of the uninitialized read.
    However, that has as a destination register rbx itself. The analysis function |checkDestRegisters| will therefore delete any entry in the map 
    |pendingUninitializedReads| associated to rbx.
    By doing so, we lose any information about uninitialized reads associated to rbx and therefore, when rbx is subsequently used, the uninitialized read won't be stored.

    To avoid this problem (happening only because mov destination and source registers are the same), we'll remove entries from |pendingUninitializedReads|
    only if that is not an auto mov.
*/
bool isAutoMov(OPCODE opcode, list<REG>* srcRegs, list<REG>* dstRegs){

    if(srcRegs == NULL || dstRegs == NULL || srcRegs->size() + dstRegs->size() <= 2 || !isMovInstruction(opcode))
        return false;

    REG srcReg = *srcRegs->begin();
    REG dstReg = *dstRegs->begin();
    return srcReg == dstReg;

}


// Returns true if the considered instruction is any kind of push instruction.
// Note that this is only useful to correctly compute sp offset of the push instructions as 0, otherwise
// the tool would consider as accessed address the last value in the sp before this instruction
// is performed.
// The size of the access should be correctly detected by PIN according to the type of push instruction.
bool isPushInstruction(OPCODE opcode){
    return
        opcode == XED_ICLASS_PUSH ||
        opcode == XED_ICLASS_PUSHA || 
        opcode == XED_ICLASS_PUSHAD || 
        opcode == XED_ICLASS_PUSHF || 
        opcode == XED_ICLASS_PUSHFD || 
        opcode == XED_ICLASS_PUSHFQ;
}

bool isPopInstruction(OPCODE opcode){
    return 
        opcode == XED_ICLASS_POP ||
        opcode == XED_ICLASS_POPA ||
        opcode == XED_ICLASS_POPAD ||
        opcode == XED_ICLASS_POPF ||
        opcode == XED_ICLASS_POPFD ||
        opcode == XED_ICLASS_POPFQ;

}

bool isXorInstruction(OPCODE opcode){
    switch(opcode){
        case XED_ICLASS_KXORB:
        case XED_ICLASS_KXORW:
        case XED_ICLASS_KXORD:
        case XED_ICLASS_KXORQ:
        case XED_ICLASS_XOR:
        case XED_ICLASS_XORPD:
        case XED_ICLASS_XORPS:
        case XED_ICLASS_PXOR:
        case XED_ICLASS_VPXOR:
        case XED_ICLASS_VPXORD:
        case XED_ICLASS_VPXORQ:
        case XED_ICLASS_VXORPD:
        case XED_ICLASS_VXORPS:

            return true;

        default:
            return false;
    }
}

bool isEndbrInstruction(OPCODE opcode){
    return 
        opcode == XED_ICLASS_ENDBR32 ||
        opcode == XED_ICLASS_ENDBR64;
}

// Similarly to the previous functions, the following returns true if the considered instruction
// is a call instruction, which pushes on the stack the return address
bool isCallInstruction(OPCODE opcode){
    return
        opcode == XED_ICLASS_CALL_FAR ||
        opcode == XED_ICLASS_CALL_NEAR;
}

// There are many ways of calling system calls, and there can be, therefore, multiple opcodes associated
// to system calls. However, our tool uses a conventional value of |XED_ICLASS_SYSCALL_AMD| to mark all 
// accesses generated by system calls, so it is enough to check for that value
bool isSyscallInstruction(OPCODE opcode){
    return opcode == XED_ICLASS_SYSCALL_AMD;
}

bool isFpuPushInstruction(OPCODE opcode){
    switch(opcode){
        case XED_ICLASS_FLD:
        case XED_ICLASS_FILD:
        case XED_ICLASS_FBLD:
        case XED_ICLASS_FLD1:
        case XED_ICLASS_FLDPI:
        case XED_ICLASS_FLDL2E:
        case XED_ICLASS_FLDL2T:
        case XED_ICLASS_FLDLG2:
        case XED_ICLASS_FLDLN2:
        case XED_ICLASS_FLDZ:
        case XED_ICLASS_FDECSTP:
            return true;
        
        default:
            return false;
    }
}

bool isFpuPopInstruction(OPCODE opcode){
    switch(opcode){
        case XED_ICLASS_FBSTP:
        case XED_ICLASS_FSTP:
        case XED_ICLASS_FISTP:
        case XED_ICLASS_FISTTP:
        case XED_ICLASS_FADDP:
        case XED_ICLASS_FSUBP:
        case XED_ICLASS_FSUBRP:
        case XED_ICLASS_FMULP:
        case XED_ICLASS_FDIVP:
        case XED_ICLASS_FDIVRP:
        case XED_ICLASS_FUCOMP:
        case XED_ICLASS_FUCOMPP:
        case XED_ICLASS_FUCOMIP:
        case XED_ICLASS_FCOMIP:
        case XED_ICLASS_FINCSTP:
        case XED_ICLASS_FCOMP:
        case XED_ICLASS_FCOMPP:
        case XED_ICLASS_FICOMP:
            return true;

        default:
            return false;
    }   
}

bool isXsaveInstruction(OPCODE opcode){
    switch(opcode){
        case XED_ICLASS_XSAVE:
        case XED_ICLASS_XSAVE64:
        case XED_ICLASS_XSAVEC:
        case XED_ICLASS_XSAVEC64:
        case XED_ICLASS_XSAVEOPT:
        case XED_ICLASS_XSAVEOPT64:
        case XED_ICLASS_XSAVES:
        case XED_ICLASS_XSAVES64:
        case XED_ICLASS_FXSAVE:
        case XED_ICLASS_FXSAVE64:
            return true;

        default:
            return false;
    }
}

bool isXrstorInstruction(OPCODE opcode){
    switch(opcode){
        case XED_ICLASS_XRSTOR:
        case XED_ICLASS_XRSTOR64:
        case XED_ICLASS_XRSTORS:
        case XED_ICLASS_XRSTORS64:
        case XED_ICLASS_FXRSTOR:
        case XED_ICLASS_FXRSTOR64:
            return true;
        
        default:
            return false;
    }
}

bool shouldLeavePending(OPCODE opcode){
    if(isXsaveInstruction(opcode))
        return true;

    if(isXrstorInstruction(opcode)){
        return true;
    }

    if(isFpuPushInstruction(opcode))
        return true;

    switch(opcode){
        case XED_ICLASS_VPBROADCASTB:
        case XED_ICLASS_VPBROADCASTW:
        case XED_ICLASS_VPBROADCASTD:
        case XED_ICLASS_VPBROADCASTQ:
        case XED_ICLASS_FBSTP:
        case XED_ICLASS_FST:
        case XED_ICLASS_FSTP:
        case XED_ICLASS_FIST:
        case XED_ICLASS_FISTP:
        case XED_ICLASS_FISTTP:
        case XED_ICLASS_CWD:
        case XED_ICLASS_CDQ:
        case XED_ICLASS_CQO:
        case XED_ICLASS_PMOVMSKB:
        case XED_ICLASS_VPMOVMSKB:
            return true;

        default: 
            return false;
    }
}

bool isMovInstruction(OPCODE opcode){
    switch(opcode){
        case XED_ICLASS_BNDMOV:

        case XED_ICLASS_CMOVB:
        case XED_ICLASS_CMOVBE:
        case XED_ICLASS_CMOVL:
        case XED_ICLASS_CMOVLE:
        case XED_ICLASS_CMOVNB:
        case XED_ICLASS_CMOVNBE:
        case XED_ICLASS_CMOVNL:
        case XED_ICLASS_CMOVNLE:
        case XED_ICLASS_CMOVNO:
        case XED_ICLASS_CMOVNP:
        case XED_ICLASS_CMOVNS:
        case XED_ICLASS_CMOVNZ:
        case XED_ICLASS_CMOVO:
        case XED_ICLASS_CMOVP:
        case XED_ICLASS_CMOVS:
        case XED_ICLASS_CMOVZ:

        case XED_ICLASS_FCMOVB:
        case XED_ICLASS_FCMOVBE:
        case XED_ICLASS_FCMOVE:
        case XED_ICLASS_FCMOVNB:
        case XED_ICLASS_FCMOVNBE:
        case XED_ICLASS_FCMOVNE:
        case XED_ICLASS_FCMOVNU:
        case XED_ICLASS_FCMOVU:

        case XED_ICLASS_KMOVB:
        case XED_ICLASS_KMOVD:
        case XED_ICLASS_KMOVQ:
        case XED_ICLASS_KMOVW:

        case XED_ICLASS_MASKMOVDQU:
        case XED_ICLASS_MASKMOVQ:

        case XED_ICLASS_MOV:
        case XED_ICLASS_MOVAPD:
        case XED_ICLASS_MOVAPS:
        case XED_ICLASS_MOVBE:
        case XED_ICLASS_MOVD:
        case XED_ICLASS_MOVDDUP:
        case XED_ICLASS_MOVDIR64B:
        case XED_ICLASS_MOVDIRI:
        case XED_ICLASS_MOVDQ2Q:
        case XED_ICLASS_MOVDQA:
        case XED_ICLASS_MOVDQU:
        case XED_ICLASS_MOVHLPS:
        case XED_ICLASS_MOVHPD:
        case XED_ICLASS_MOVHPS:
        case XED_ICLASS_MOVLHPS:
        case XED_ICLASS_MOVLPD:
        case XED_ICLASS_MOVLPS:
        case XED_ICLASS_MOVMSKPD:
        case XED_ICLASS_MOVMSKPS:
        case XED_ICLASS_MOVNTDQ:
        case XED_ICLASS_MOVNTDQA:
        case XED_ICLASS_MOVNTI:
        case XED_ICLASS_MOVNTPD:
        case XED_ICLASS_MOVNTPS:
        case XED_ICLASS_MOVNTQ:
        case XED_ICLASS_MOVNTSD:
        case XED_ICLASS_MOVNTSS:
        case XED_ICLASS_MOVQ:
        case XED_ICLASS_MOVQ2DQ:
        case XED_ICLASS_MOVSB:
        case XED_ICLASS_MOVSD:
        case XED_ICLASS_MOVSD_XMM:
        case XED_ICLASS_MOVSHDUP:
        case XED_ICLASS_MOVSLDUP:
        case XED_ICLASS_MOVSQ:
        case XED_ICLASS_MOVSS:
        case XED_ICLASS_MOVSW:
        case XED_ICLASS_MOVSX:
        case XED_ICLASS_MOVSXD:
        case XED_ICLASS_MOVUPD:
        case XED_ICLASS_MOVUPS:
        case XED_ICLASS_MOVZX:
        /* NOT FOUND IN THE INTEL ISA REFERENCE MANUAL
        case XED_ICLASS_MOV_CR:
        case XED_ICLASS_MOV_DR:
        */

        case XED_ICLASS_PMOVMSKB:
        case XED_ICLASS_PMOVSXBD:
        case XED_ICLASS_PMOVSXBQ:
        case XED_ICLASS_PMOVSXBW:
        case XED_ICLASS_PMOVSXDQ:
        case XED_ICLASS_PMOVSXWD:
        case XED_ICLASS_PMOVSXWQ:
        case XED_ICLASS_PMOVZXBD:
        case XED_ICLASS_PMOVZXBQ:
        case XED_ICLASS_PMOVZXBW:
        case XED_ICLASS_PMOVZXDQ:
        case XED_ICLASS_PMOVZXWD:
        case XED_ICLASS_PMOVZXWQ:

        case XED_ICLASS_REP_MOVSB:
        case XED_ICLASS_REP_MOVSD:
        case XED_ICLASS_REP_MOVSQ:
        case XED_ICLASS_REP_MOVSW:

        case XED_ICLASS_VMASKMOVDQU:
        case XED_ICLASS_VMASKMOVPD:
        case XED_ICLASS_VMASKMOVPS:

        case XED_ICLASS_VMOVAPD:
        case XED_ICLASS_VMOVAPS:
        case XED_ICLASS_VMOVD:
        case XED_ICLASS_VMOVDDUP:
        case XED_ICLASS_VMOVDQA:
        case XED_ICLASS_VMOVDQA32:
        case XED_ICLASS_VMOVDQA64:
        case XED_ICLASS_VMOVDQU:
        case XED_ICLASS_VMOVDQU16:
        case XED_ICLASS_VMOVDQU32:
        case XED_ICLASS_VMOVDQU64:
        case XED_ICLASS_VMOVDQU8:
        case XED_ICLASS_VMOVHLPS:
        case XED_ICLASS_VMOVHPD:
        case XED_ICLASS_VMOVHPS:
        case XED_ICLASS_VMOVLHPS:
        case XED_ICLASS_VMOVLPD:
        case XED_ICLASS_VMOVLPS:
        case XED_ICLASS_VMOVMSKPD:
        case XED_ICLASS_VMOVMSKPS:
        case XED_ICLASS_VMOVNTDQ:
        case XED_ICLASS_VMOVNTDQA:
        case XED_ICLASS_VMOVNTPD:
        case XED_ICLASS_VMOVNTPS:
        case XED_ICLASS_VMOVQ:
        case XED_ICLASS_VMOVSD:
        case XED_ICLASS_VMOVSHDUP:
        case XED_ICLASS_VMOVSLDUP:
        case XED_ICLASS_VMOVSS:
        case XED_ICLASS_VMOVUPD:
        case XED_ICLASS_VMOVUPS:

        case XED_ICLASS_VPCMOV:

        case XED_ICLASS_VPMASKMOVD:
        case XED_ICLASS_VPMASKMOVQ:

        case XED_ICLASS_VPMOVB2M:
        case XED_ICLASS_VPMOVD2M:
        case XED_ICLASS_VPMOVDB:
        case XED_ICLASS_VPMOVDW:
        case XED_ICLASS_VPMOVM2B:
        case XED_ICLASS_VPMOVM2D:
        case XED_ICLASS_VPMOVM2Q:
        case XED_ICLASS_VPMOVM2W:
        case XED_ICLASS_VPMOVMSKB:
        case XED_ICLASS_VPMOVQ2M:
        case XED_ICLASS_VPMOVQB:
        case XED_ICLASS_VPMOVQD:
        case XED_ICLASS_VPMOVQW:
        case XED_ICLASS_VPMOVSDB:
        case XED_ICLASS_VPMOVSDW:
        case XED_ICLASS_VPMOVSQB:
        case XED_ICLASS_VPMOVSQD:
        case XED_ICLASS_VPMOVSQW:
        case XED_ICLASS_VPMOVSWB:
        case XED_ICLASS_VPMOVSXBD:
        case XED_ICLASS_VPMOVSXBQ:
        case XED_ICLASS_VPMOVSXBW:
        case XED_ICLASS_VPMOVSXDQ:
        case XED_ICLASS_VPMOVSXWD:
        case XED_ICLASS_VPMOVSXWQ:
        case XED_ICLASS_VPMOVUSDB:
        case XED_ICLASS_VPMOVUSDW:
        case XED_ICLASS_VPMOVUSQB:
        case XED_ICLASS_VPMOVUSQD:
        case XED_ICLASS_VPMOVUSQW:
        case XED_ICLASS_VPMOVUSWB:
        case XED_ICLASS_VPMOVW2M:
        case XED_ICLASS_VPMOVWB:
        case XED_ICLASS_VPMOVZXBD:
        case XED_ICLASS_VPMOVZXBQ:
        case XED_ICLASS_VPMOVZXBW:
        case XED_ICLASS_VPMOVZXDQ:
        case XED_ICLASS_VPMOVZXWD:
        case XED_ICLASS_VPMOVZXWQ:
            
            return true;

        default:
            return false;
    }
}

bool isCmpInstruction(OPCODE opcode){
    /*
    Not included instructions:
    [*] XED_ICLASS_CMPXCHG (all variants)
    [*] XED_ICLASS_REP[E | NE]_CMP (all variants)
    */

    switch(opcode){
        case XED_ICLASS_CMP:
        case XED_ICLASS_CMPPD:
        case XED_ICLASS_CMPPS:
        case XED_ICLASS_CMPSB:
        case XED_ICLASS_CMPSD:
        case XED_ICLASS_CMPSD_XMM:
        case XED_ICLASS_CMPSQ:
        case XED_ICLASS_CMPSS:
        case XED_ICLASS_CMPSW:
        case XED_ICLASS_COMISD:
        case XED_ICLASS_COMISS:
        case XED_ICLASS_PCMPEQB:
        case XED_ICLASS_PCMPEQD:
        case XED_ICLASS_PCMPEQQ:
        case XED_ICLASS_PCMPEQW:
        case XED_ICLASS_PCMPESTRI:
        case XED_ICLASS_PCMPESTRI64:
        case XED_ICLASS_PCMPESTRM:
        case XED_ICLASS_PCMPESTRM64:
        case XED_ICLASS_PCMPGTB:
        case XED_ICLASS_PCMPGTD:
        case XED_ICLASS_PCMPGTQ:
        case XED_ICLASS_PCMPGTW:
        case XED_ICLASS_PCMPISTRI:
        case XED_ICLASS_PCMPISTRI64:
        case XED_ICLASS_PCMPISTRM:
        case XED_ICLASS_PFCMPEQ:
        case XED_ICLASS_PFCMPGE:
        case XED_ICLASS_PFCMPGT:
        case XED_ICLASS_VCMPPD:
        case XED_ICLASS_VCMPPS:
        case XED_ICLASS_VCMPSD:
        case XED_ICLASS_VCMPSS:
        case XED_ICLASS_VPCMPB:
        case XED_ICLASS_VPCMPD:
        case XED_ICLASS_VPCMPEQB:
        case XED_ICLASS_VPCMPEQD:
        case XED_ICLASS_VPCMPEQQ:
        case XED_ICLASS_VPCMPEQW:
        case XED_ICLASS_VPCMPESTRI:
        case XED_ICLASS_VPCMPESTRI64:
        case XED_ICLASS_VPCMPESTRM:
        case XED_ICLASS_VPCMPESTRM64:
        case XED_ICLASS_VPCMPGTB:
        case XED_ICLASS_VPCMPGTD:
        case XED_ICLASS_VPCMPGTQ:
        case XED_ICLASS_VPCMPGTW:
        case XED_ICLASS_VPCMPISTRI:
        case XED_ICLASS_VPCMPISTRI64:
        case XED_ICLASS_VPCMPISTRM:
        case XED_ICLASS_VPCMPQ:
        case XED_ICLASS_VPCMPUB:
        case XED_ICLASS_VPCMPUD:
        case XED_ICLASS_VPCMPUQ:
        case XED_ICLASS_VPCMPUW:
        case XED_ICLASS_VPCMPW:
        case XED_ICLASS_FCOM:
        case XED_ICLASS_FCOMI:
        case XED_ICLASS_FCOMIP:
        case XED_ICLASS_FCOMP:
        case XED_ICLASS_FCOMPP:
        case XED_ICLASS_FICOM:
        case XED_ICLASS_FICOMP:
        case XED_ICLASS_FUCOM:
        case XED_ICLASS_FUCOMI:
        case XED_ICLASS_FUCOMIP:
        case XED_ICLASS_FUCOMP:
        case XED_ICLASS_FUCOMPP:
        case XED_ICLASS_PTEST:
        case XED_ICLASS_TEST:
        case XED_ICLASS_UCOMISD:
        case XED_ICLASS_UCOMISS:
            return true;

        default:
            return false;
    }
}