#!/usr/bin/env python3

import sys
import os
import shutil as su
import subprocess as subp
import threading as t
import signal as sig
import time
import argparse as ap
import re
import random

class MissingExecutableError(Exception):
    pass

class TooManyProcessesError(Exception):
    pass


PROGRESS_UNIT = 0
PROGRESS_LEN = 30
PROGRESS = 0
LAST_PROGRESS_TASK = None
LOCK = t.Lock()

POWER_SHED = {"explore", "fast", "coe", "quad", "lin", "exploit"}
EXPERIMENTAL_POWER_SCHED = {"mmopt", "rare", "seek"}
ALREADY_LAUNCHED_SCHED = set()


def parse_help_flag(argv_str):
    pat = r"(\s-h)($|\s)"
    match = re.search(pat, argv_str)
    return match is not None

def parse_executable(exec_str):
    splitted_exec = exec_str.split(" ")
    exec_path = splitted_exec[0]
    exec_path = adjust_exec_path(exec_path)
    executable = [exec_path] + splitted_exec[1:]
    executable = " ".join(executable)

    if not os.path.exists(exec_path):
        raise IOError("Executable {0} does not exist. Check the executable path and try again".format(exec_path))

    return executable


def parse_args(args):
    
    class HelpFormatter(ap.ArgumentDefaultsHelpFormatter, ap.RawDescriptionHelpFormatter):
        def _format_usage(self, usage, actions, groups, prefix):
            ret_usage = super()._format_usage(usage, actions, groups, prefix).split("\n\n")[0]
            ret_usage += " -- /path/to/executable <executable args>\n\n"
            return ret_usage


    def parse_exec_time(s):
        pat = r"([1-9][0-9]*)([smh])?$"
        m = re.search(pat, s)
        if m is None:
            raise ap.ArgumentTypeError(
                "Malformed execution time string. Accepted format: "
                "<Integer> [s|m|h]. If neither of the unit modifier is used, time will be measured in seconds."
            )

        val = int(m[1])
        modifier = m[2]

        if modifier is not None:
            if modifier == 'm':
                val *= 60
            elif modifier == 'h':
                val *= 3600

        return val



    parser = ap.ArgumentParser(formatter_class = HelpFormatter)

    parser.add_argument("--fuzz-out", "-f", 
        default = "out", 
        help = "Name of the folder containing the results generated by the fuzzer",
        dest = "fuzz_out"
    )

    parser.add_argument("--out", "-o",
        default = "tracer_out",
        help = "Name of the folder containing the results generated by the tracer",
        dest = "tracer_out"
    )

    parser.add_argument("--fuzz-dir", "-d",
        default = "afl_test",
        help =  "Name of the folder containing all the requirements to run the fuzzer. This folder must already exist and "
                "contain all the files/directories required by the fuzzer.",
        dest = "fuzz_dir"
    )

    parser.add_argument("--fuzz-in", "-i",
        default = "in",
        help =  "Name of the folder containing the initial testcases for the fuzzer. This folder must already exist "
                "and contain the testcases",
        dest = "fuzz_in"
    )

    parser.add_argument("--backup", "-b",
        default = "olds",
        help = "Name of the folder used to move old results of past executions before running the tracer again.",
        dest = "olds_dir"
    )

    parser.add_argument("--admin-priv", "-a",
        action = "store_true",
        help =  "Flag used to specify the user has administration privileges (e.g. can use sudo on Linux). This can be used "
                "by the launcher in order to execute a configuration script that, according to the fuzzer's manual, should "
                "speedup the fuzzing task.",
        dest = "admin_priv"
    )

    parser.add_argument("--time", "-t",
        default = "60",
        help =  "Specify fuzzer's execution time. By default, the value is measured in seconds. The following modifiers can "
                "be used: 's', 'm', 'h', to specify time respectively in seconds, minutes or hours",
        dest = "exec_time",
        type = parse_exec_time
    )

    default_slaves_nr = 0
    default_processes_nr = 1

    parser.add_argument("--slaves", "-s",
        default = default_slaves_nr,
        help =  "Specify the number of slave fuzzer instances to run. The fuzzer always launches at least the main instance. " 
                "Launching more instances uses more resources, but allows to find more inputs in a smaller time span. "
                "It is advisable to use this option combined with -p, if possible. Note that the total amount of launched processes won't be "
                "higher than the total number of available cpus, unless --ignore-cpu-count flag is enabled. "
                "However, it is very advisable to launch at least 1 slave instance.",
        dest = "slaves",
        type = int
    )

    parser.add_argument("--processes", "-p",
        default = default_processes_nr,
        help =  "Specify the number of processes executing the tracer. Using more processes allows to launch the tracer with more inputs in the same time span. "
                "It is useless to use many processes for the tracer if the fuzzer finds new inputs very slowly. "
                "If there are few resources available, it is therefore advisable to dedicate them to fuzzer instances rather then to tracer processes. "
                "Note that the total amount of launched processes won't be higher than the total number of available cpus, unless --ignore-cpu-count "
                "flag is enabled.",
        dest = "processes",
        type = int
    )

    parser.add_argument("--ignore-cpu-count",
        action = "store_true",
        help =  "Flag used to ignore the number of available cpus and force the number of processes specified with -s and -p to be launched even if"
                "they are more than that.",
        dest = "ignore_cpu_count"
    )

    parser.epilog = "After the arguments for the script, the user must pass '--' followed by the executable path and the arguments that should be passed to it, "\
                    "except the file it reads from, if any.\n\n"\
                    "Example: ./memTracer.py -- /path/to/the/executable arg1 arg2 --opt1\n\n"\
                    "Remember to NOT PASS the input file as an argument for the executable, as it will be automatically passed by the fuzzer starting "\
                    "from the initial testcases and followed by the generated inputs."

    ret = parser.parse_args(args)

    if ret.slaves < default_slaves_nr:
        print(  "WARNING: The number of slave fuzzer instances must be greater or equal to {0}. "
                "Falling back to default value: {0} slave instances will be launched".format(default_slaves_nr))
        ret.slaves = default_slaves_nr

    if ret.processes < default_processes_nr:
        print(  "WARNING: The number of slave fuzzer instances must be greater or equal to {0}. "
                "Falling back to default value: {0} tracer process will be launched".format(default_processes_nr))
        ret.processes = default_processes_nr

    return ret


def launchTracer(exec_cmd, args, fuzz_int_event: t.Event):

    def remove_terminated_processes(proc_list):
        ongoing_indices = [i for i, el in enumerate(map(lambda x: x.poll(), proc_list)) if el is None]
        ret = [el for i, el in enumerate(proc_list) if i in ongoing_indices]
        return ret

    def wait_process_termination(proc_list):
        ret = proc_list
        while len(ret) == len(proc_list):
            print("Waiting for a process to terminate")
            time.sleep(3)
            ret = remove_terminated_processes(proc_list)
        print("Process terminated")
        return ret



    print("Tracer thread started...")
    fuzz_dir = args.fuzz_dir
    fuzz_out = os.path.join(fuzz_dir, args.fuzz_out)
    tracer_out = os.path.join(fuzz_dir, args.tracer_out)
    inputs_dir = os.path.join(fuzz_out, "Main", "queue")
    launcher_path = os.path.join(os.getcwd(), "launcher")
    tracer_cmd = [launcher_path, "-o", "./overlaps.bin", "--"] + [exec_cmd]
    traced_inputs = {".state"}
    os.mkdir(tracer_out)
    new_inputs_found = True

    processes = list()

    while not os.path.exists(inputs_dir):
        print("Waiting for inputs directory to be generated by the fuzzer...")
        if fuzz_int_event.is_set():
            print()
            print("Fuzzer died before creating inputs directory.")
            print("This probably means there has been an error during fuzzer's startup.")
            print("Try to launch the script again using -a option. NOTE: you must have admin privileges (i.e. sudo user on Linux)")
            print()
            print("Tracer thread will be shutdown")
            return
        time.sleep(1)

    # Loop interrupts if and only if there are no new_inputs and the fuzzer has been interrupted
    while new_inputs_found or not fuzz_int_event.is_set():
        processes = remove_terminated_processes(processes)
        inputs = set()
        for f in os.scandir(inputs_dir):
            inputs.add(f.name)

        new_inputs = inputs.difference(traced_inputs)
        if(len(new_inputs) == 0):
            new_inputs_found = False
            print("Waiting the fuzzer for new inputs")
            time.sleep(10)
            continue

        new_inputs_found = True

        for f in new_inputs:
            input_folder = os.path.join(tracer_out, f)
            os.mkdir(input_folder)
            input_cpy_path = os.path.join(input_folder, "input")
            su.copy(os.path.join(inputs_dir, f), input_cpy_path)
            print()
            tracer_cmd[2] = os.path.join(input_folder, "overlaps.bin")
            full_cmd = tracer_cmd + [input_cpy_path]
            if len(processes) == args.processes:
                processes = wait_process_termination(processes)
            processes.append(subp.Popen(full_cmd, stdout = subp.DEVNULL, stderr = subp.DEVNULL))
            print("{0} is running".format(f))
            print()

        traced_inputs.update(new_inputs)
        time.sleep(10)


def move_directory(src, dst_dir, new_name = None):
    if not os.path.exists(dst_dir):
        os.makedirs(dst_dir)

    if not new_name is None:
        dirname = os.path.dirname(src)
        new_path = os.path.join(dirname, new_name)
        os.rename(src, new_path)
        src = new_path

    basename = os.path.basename(src)
    su.move(src, os.path.join(dst_dir, basename))


def count_dir_content(dir_path):
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)
        return 0

    return len(os.listdir(dir_path))


def adjust_exec_path(path):
    if(os.path.isabs(path)):
        return path

    return os.path.realpath(path)


def main():
    global PROGRESS
    global PROGRESS_UNIT

    def build_slave_cmd(slave_id, fuzz_in, fuzz_out, executable):
        global POWER_SHED
        global EXPERIMENTAL_POWER_SCHED
        global ALREADY_LAUNCHED_SCHED

        if(len(ALREADY_LAUNCHED_SCHED) == 0):
            selected = "fast"
        else:
            r = random.random()
            sched_set = POWER_SHED if r <= 0.90 else EXPERIMENTAL_POWER_SCHED
            diff = sched_set.difference(ALREADY_LAUNCHED_SCHED)
            if(len(diff) != 0):
                sched_set = diff
            selected = random.choice(list(sched_set))

        ALREADY_LAUNCHED_SCHED.update({selected})

        print("Launching slave instance nr {0} with power schedule {1}".format(slave_id, selected))
        cmd = ["afl-fuzz", "-Q", "-S", "Slave_{0}".format(slave_id), "-p", selected, "-i", fuzz_in, "-o", fuzz_out, "--", executable, "@@"]
        return cmd


    def send_int(process: subp.Popen, slaves):
        for slave in slaves:
            slave.send_signal(sig.SIGINT)
        process.send_signal(sig.SIGINT)


    def print_empty_progress(fuzz_int_ev: t.Event):
        global PROGRESS_LEN
        global LAST_PROGRESS_TASK
        global LOCK

        out = ["|"]
        out.append(" " * PROGRESS_LEN)
        out.append("|")
        print("".join(out))

        LOCK.acquire()
        LAST_PROGRESS_TASK = t.Timer(10, print_progress, [fuzz_int_ev])
        LAST_PROGRESS_TASK.start()
        LOCK.release()


    # |fuzz_int_event| is required because 2 different threads may be running |print_progress|,
    # one with the |finished| flag enabled, and one with the flag disabled.
    # If in that situation the flag-enabled thread acquires the lock first, the flag-disabled
    # thread will acquire it later, setting a new timer, thus never ending setting new timers
    def print_progress(fuzz_int_ev: t.Event, finished = False):
        global PROGRESS
        global PROGRESS_LEN
        global LAST_PROGRESS_TASK
        global LOCK

        if finished:
            progress_bar = PROGRESS_LEN
        else:
            PROGRESS += 10
            progress_bar = PROGRESS // PROGRESS_UNIT
        out = ["|"]
        out.append("=" * progress_bar)
        out.append(" " * (PROGRESS_LEN - progress_bar))
        out.append("|")
        print("".join(out))

        LOCK.acquire()
        if not finished and not fuzz_int_ev.is_set():
            LAST_PROGRESS_TASK = t.Timer(10, print_progress, [fuzz_int_ev])
            LAST_PROGRESS_TASK.start()
        elif not LAST_PROGRESS_TASK is None:
            LAST_PROGRESS_TASK.cancel()
        LOCK.release()


    # sys_args contains the command-line arguments divided in 2 parts:
    # the first element contains a string representing the arguments for this script;
    # the second element contains a string representing the executable and its command-line arguments
    argv_str = " ".join(sys.argv)

    # Check if -h is passed as an argument
    help_requested = parse_help_flag(argv_str)
    if help_requested:
        # Since -h is passed as an argument, parse_args will simply print the help text and return
        parse_args(sys.argv)

    pat = r"(\s)(--)([\s\n]|$)"
    match = re.search(pat, argv_str)

    # If there's no '--' in the list of command line arguments, the script can't say which is the executable
    if match is None:
        raise MissingExecutableError(
            "Executable path is missing. Provide an executable path and its arguments after '--'.\n"
            "Example: ./memTracer.py -- /path/to/executable arg1 arg2 -opt1"
        )

    sys_args = argv_str.split(match[0])

    # If no executable is provided, raise an error
    if len(sys_args[1]) == 0:
        raise MissingExecutableError(
            "Executable path is missing. Provide an executable path and its arguments after '--'.\n"
            "Example: ./memTracer.py -- /path/to/executable arg1 arg2 -opt1"
        )

    # args is a Namespace object, containing the arguments parsed by parse_args
    args = parse_args(sys_args[0].split(" ")[1:])

    # executable is a string specifying the executable path followed by the arguments to be passed to it
    executable = parse_executable(sys_args[1])

    WORKING_DIR = os.getcwd()
    FUZZ_DIR = os.path.join(WORKING_DIR, args.fuzz_dir)
    FUZZ_OUT = os.path.join(FUZZ_DIR, args.fuzz_out)
    FUZZ_IN = os.path.join(FUZZ_DIR, args.fuzz_in)
    FUZZ_OLDS = os.path.join(FUZZ_DIR, args.olds_dir)

    if not os.path.exists(FUZZ_DIR):
        raise IOError("Folder {0} must exist and must contain all the required files/folders for the fuzzer to work (e.g. initial testcases)".format(FUZZ_DIR))

    if not os.path.exists(FUZZ_IN):
        raise IOError("Folder {0} must exist and contain at least 1 initial testcase".format(FUZZ_IN))

    tracer_out = os.path.join(FUZZ_DIR, args.tracer_out)

    # If out (and therefore tracer_out) exists in the fuzzer folder, we need to move them away.
    # First, we need to update last_count value
    if os.path.exists(FUZZ_OUT) or os.path.exists(tracer_out):
        last_old = os.path.join(FUZZ_DIR, "last_old")
        last_count = None

        # If file last_old does not exist, create it. last_count value will be 0
        if not os.path.exists(last_old):
                last_count = 0
                with open(last_old, "w") as f:
                    f.write(str(last_count))
        # otherwise, read the value stored in the file last_old. If it is a number, set last_count to that 
        # value, otherwise, the file is malformed, so we need to actually count the folders already stored in
        # FUZZ_OLDS
        else:
            with open(last_old, "r+") as f:
                content = f.readline()
                if len(content) == 0:
                    last_count = 0
                else:
                    try:
                        last_count = int(content)
                        last_count += 1
                    except ValueError:
                        last_count = count_dir_content(FUZZ_OLDS)

                f.seek(0)
                f.write(str(last_count))
                f.truncate()

        backup_dir = os.path.join(FUZZ_OLDS, str(last_count))
        
        if os.path.exists(FUZZ_OUT):
            move_directory(FUZZ_OUT, backup_dir)

        if os.path.exists(tracer_out):
            move_directory(tracer_out, backup_dir)

        if os.path.exists(tracer_out):
            raise IOError("Directory {0} already exists. Please move or remove it before running the tracer.".format(tracer_out))
        
        if os.path.exists(FUZZ_OUT):
            raise IOError("Directory {0} already exists. Please move or remove it before running the tracer.".format(FUZZ_OUT))


    # Start AFL fuzzer
    if(args.admin_priv):
        p = subp.Popen(["sudo", "afl-system-config"])
        p.wait()
    fuzz_cmd = ["afl-fuzz", "-Q", "-M", "Main", "-i", FUZZ_IN, "-o", FUZZ_OUT, "--", executable, "@@"]

    cpus = os.cpu_count()
    if cpus is None:
        print("Warning: cpu count cannot be determined and will be ignored.")
        args.ignore_cpu_count = True

    if not args.ignore_cpu_count:
        # +1 is required because args.slaves contains only the additional fuzzer instances. The +1 counts the main instance
        p = args.slaves + args.processes + 1
        if p > cpus:
            raise TooManyProcessesError("Available cpus ({0}) are less than the number of processes to be launched ({1})".format(cpus, p))

    stop_after_seconds = args.exec_time
    PROGRESS_UNIT = stop_after_seconds // PROGRESS_LEN
    if PROGRESS_UNIT <= 0:
        PROGRESS_UNIT = PROGRESS_LEN

    print("Launching Main fuzzer instance...")
    p = subp.Popen(fuzz_cmd, stdout = subp.DEVNULL, stderr = subp.DEVNULL)
    slaves = list()
    for i in range(args.slaves):
        cmd = build_slave_cmd(i, FUZZ_IN, FUZZ_OUT, executable)
        slaves.append(subp.Popen(cmd, stdout = subp.DEVNULL, stderr = subp.DEVNULL))

    print()
    print("Fuzzer will be interrupted in {0} seconds...".format(stop_after_seconds))

    fuzzer_interrupted_event = t.Event()
    int_timer = t.Timer(stop_after_seconds, send_int, [p, slaves])
    int_timer.start()
    print_empty_progress(fuzzer_interrupted_event)

    tracerThread = t.Thread(target = launchTracer, args = [executable, args, fuzzer_interrupted_event])
    tracerThread.start()

    # Wait for the fuzzer to be interrupted
    for slave in slaves:
        slave.wait()
    p.wait()
    fuzzer_interrupted_event.set()
    print_progress(fuzzer_interrupted_event, True)
    # If the fuzzer terminates before the requested time (e.g. if there are no initial testcases)
    # it is not necessary to wait the whole time to send a SIGINT
    int_timer.cancel()
    print("Fuzzer interrupted")
    print()

    # Wait for the tracer thread to run with all the inputs found by the fuzzer
    tracerThread.join()
    print("All finished")


if __name__ == "__main__":
    main()