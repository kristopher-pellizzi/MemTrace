# Tests

*MemTrace* have been tested in a docker container in order to make them easily reproducible.
Folder *Tests* contains a set of scripts that will automatically perform the tests done during the validation of the tool, also compiling the required binaries.



## Timing test

The script *timing_test.sh* will execute *MemTrace* with all the utilities from *Coreutils-8.32*.
Moreover, in order to enable a comparison, the exact same tests will be executed by using *memcheck* (https://valgrind.org/docs/manual/mc-manual.html) as an analysis tool.

When the script finished executing, 2 files called *memtrace_execution_times.csv* and *valgrind_execution_times.csv* will be available in folder *Tests*.
In order to be clearer, it is possible to import the csv files into a spreadsheet program, such as *MS Excel*.



## Functional tests

### Uninitialized reads detection

*MemTrace* has been tested using some binaries with known uninitialized read vulnerabilities.
In this set of tests, the goal was to check whether *MemTrace* was able to report the known vulnerability when the binary was executed with an input triggering it.

The script *triggering_test.py* will automatically perform the same set of tests, generating folder *triggering_test_out*, which contains a directory for each executed test, in turns containing the generated binary report and the output of the executed command.

Script *valgrind_triggering_test.py* will perform the same set of tests using *memcheck* as an analysis tool.
This is done in order to enable a comparison over the number of generated warnings.
***NOTE***: *executing this script will replace the output of script triggering_test.py*.



### Fuzzing efficacy

The same set of binaries used for [uninitialized reads detection](#Uninitialized-reads-detection) tests has been used to verify the efficacy of the combined execution of *MemTrace* with *AFL++*.

In this case, the goal was verifying whether the fuzzer was able to generate inputs allowing *MemTrace* to detect an existing vulnerability automatically, using, as initial inputs, some random inputs.

The script *fuzzing_test.py* will automatically perform the same set of tests.
For each binary, 4 instances of the fuzzer will be launched, which will fuzz the binary for **8 hours**. In the meanwhile, each input generated by AFL++ is used to execute the binary with *MemTrace*.

Unfortunately, different binaries required different configurations of *MemTrace*, so it is not possible to perform **all** the tests in parallel.

Eventually, folder *fuzzing_test_out* will contain a directory for each binary, containing, among other things, the report merging the results of all the executions of the binary.

***NOTE***: *as mentioned, the fuzzer will fuzz the binary for 8 hours using 4 parallel instances. Moreover, 4 parallel instances of *MemTrace* will handle the inputs generated by AFL++. So, this test should be done on machines with many resources available (e.g. a remote server) and, since some tests require to be serialized because of the different configuration of *MemTrace*, it may require many hours to complete.