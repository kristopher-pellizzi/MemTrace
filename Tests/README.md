# Tests

*MemTrace* have been tested in a docker container in order to make them easily reproducible.
Folder *Tests* contains a set of scripts that will automatically perform the tests done during the validation of the tool, also compiling the required binaries.



## Timing test

The script *timing_test.sh* will execute *MemTrace* with all the utilities from *Coreutils-8.32*.
Moreover, in order to enable a comparison, the exact same tests will be executed by using *memcheck* (https://valgrind.org/docs/manual/mc-manual.html) as an analysis tool.

When the script finished executing, 2 files called *memtrace_execution_times.csv* and *valgrind_execution_times.csv* will be available in folder *Tests*.
In order to be clearer, it is possible to import the csv files into a spreadsheet program, such as *MS Excel*.



## Functional tests

### Uninitialized reads detection

*MemTrace* has been tested using some binaries with known uninitialized read vulnerabilities.
In this set of tests, the goal was to check whether *MemTrace* was able to report the known vulnerability when the binary was executed with an input triggering it.

The script *triggering_test.py* will automatically perform the same set of tests, generating folder *triggering_test_out*, which contains a directory for each executed test, in turns containing the generated binary report and the output of the executed command.

Script *valgrind_triggering_test.py* will perform the same set of tests using *memcheck* as an analysis tool.
This is done in order to enable a comparison over the number of generated warnings.
***NOTE***: *executing this script will replace the output of script triggering_test.py*.



### Fuzzing efficacy

The same set of binaries used for [uninitialized reads detection](#Uninitialized-reads-detection) tests has been used to verify the efficacy of the combined execution of *MemTrace* with *AFL++*.

In this case, the goal was verifying whether the fuzzer was able to generate inputs allowing *MemTrace* to detect an existing vulnerability automatically, using, as initial inputs, some random inputs.

The script *fuzzing_test.py* will automatically perform the same set of tests.
For each binary, 4 instances of the fuzzer will be launched, which will fuzz the binary for **8 hours**. In the meanwhile, each input generated by AFL++ is used to execute the binary with *MemTrace*.

Unfortunately, different binaries required different configurations of *MemTrace*, so it is not possible to perform **all** the tests in parallel.

Eventually, folder *fuzzing_test_out* will contain a directory for each binary, containing, among other things, the report merging the results of all the executions of the binary.

***NOTE***: *as mentioned, the fuzzer will fuzz the binary for 8 hours using 4 parallel instances. Moreover, 4 parallel instances of *MemTrace* will handle the inputs generated by AFL++. So, this test should be done on machines with many resources available (e.g. a remote server) and, since some tests require to be serialized because of the different configuration of *MemTrace*, it may require many hours to complete.



## Ubuntu server manifest testing

In order to try and find vulnerabilities in some of the most used tools, we tested *MemTrace* with binaries from the [ubuntu server manifest](https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64-root.manifest).

To do that, script *install_manifest.sh* will install all the binaries listed in the manifest, and script *long_term_tests.py* will launch *MemTrace* with 10 random binaries from folder */usr/bin*, which is the usual default folder for installed binaries in ubuntu, executing them in a *tmux* session, each on a different tmux window.

The launched tests will execute the fuzzer for 24 hours, and will use 2 parallel instances of the fuzzer and 2 parallel instances of the tracer.
So, the script will execute **up to 40 parallel processes** on every execution.

Note that the script will generate 2 files in the current working directory: *tested_list.txt* and *non_testable_list.txt*. These files will hold, respectively, the list of already tested binaries (to avoid execute the same binary twice) and a list of non testable executables found in */usr/bin*.
An executable can be marked as *non executable* due to 2 main reasons:
1. The executable is a script (shell, python, bash, perl...). In this case, *AFL++* will simply print an error telling it won't fuzz a shell script and close.
Since the fuzzer won't work with them, they are simply skipped.
2. A list of "dangerous" binaries has been hard-coded in the script. Those binaries are the ones that allow the user to modify some attributes of any file (e.g. chmod, chown, chgrp, etc...). They are considered "dangerous" because it may happen that fuzzing those binaries, some important files will be made unaccessible.
For instance, during a test *chmod* changes the permission on the whole */usr/bin* folder, making **all** the binaries stored there *non executable*.

The 2 files mentioned above must be in the current working directory when *long_term_tests.py* is launched, if you want to **resume** the tests.
In this case, all the already tested binaries won't be tested again, and 10 **new** binaries will be taken from */usr/bin*.
If the 2 files are missing, the script will generate them, but will start from the beginning.